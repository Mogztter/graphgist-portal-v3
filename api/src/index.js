import { ApolloServer, AuthenticationError } from "apollo-server-express";
import express from "express";
import neo4j from "neo4j-driver";
import { makeAugmentedSchema, neo4jgraphql } from "neo4j-graphql-js";
import { v4 as uuidv4 } from "uuid";
import Asciidoctor from "asciidoctor";
import { getGraphGistByUUID } from "./graphgists";

import dotenv from "dotenv";
dotenv.config();

import { auth0Verify, getUser } from "./auth";
import { typeDefs } from "./graphql-schema";

/*
 * Create a Neo4j driver instance to connect to the database
 * using credentials specified as environment variables
 * with fallback to defaults
 */
export const driver = neo4j.driver(
  process.env.NEO4J_URI || "bolt://localhost:7687",
  neo4j.auth.basic(
    process.env.NEO4J_USER || "neo4j",
    process.env.NEO4J_PASSWORD || "neo4j"
  )
);

const app = express();

/*
 * Create an executable GraphQL schema object from GraphQL type definitions
 * including autogenerated queries and mutations.
 * Optionally a config object can be included to specify which types to include
 * in generated queries and/or mutations. Read more in the docs:
 * https://grandstack.io/docs/neo4j-graphql-js-api.html#makeaugmentedschemaoptions-graphqlschema
 */

const S3_BUCKET_NAME = process.env.S3_BUCKET_NAME;

function convertAsciiDocToHtml(asciidoc) {
  const asciidoctor = Asciidoctor();
  return asciidoctor.convert(asciidoc, {
    toc: "macro",
    "toc-placement": "macro",
    "env-graphgist": true,
  });
}

export const schema = makeAugmentedSchema({
  typeDefs,
  resolvers: {
    Mutation: {
      UpdateUser: async (obj, args, context, info) => {
        const session = context.driver.session();
        const txc = session.beginTransaction();
        try {
          const profile = args.user;
          const user = await context.user;

          const result = await txc.run(
            `
            MATCH (u:User {uuid: $uuid})
            MERGE (u)-[:IS_PERSON]->(p:Person)
            SET u += $user
            SET p += $person
            RETURN u, p
          `,
            {
              uuid: user.uuid,
              user: {
                name: profile.name,
                twitter_username: profile.twitter_username,
                email: profile.email,
              },
              person: {
                name: profile.name,
                twitter_username: profile.twitter_username,
                email: profile.email,
                tshirt_size: profile.tshirt_size,
                tshirt_size_other: profile.tshirt_size_other,
              },
            }
          );
          await txc.commit();
          return neo4jgraphql(obj, { uuid: user.uuid }, context, info);
        } catch (error) {
          console.error(error);
        }

        return null;
      },
      Authenticate: async (root, args, context, info) => {
        const session = context.driver.session();
        const txc = session.beginTransaction();

        try {
          const user = await auth0Verify(args.token);
          const [provider, uid] = user.sub.split("|");

          const result = await txc.run(
            `MATCH (u:User) WHERE (u.provider = $provider AND u.uid = $uid) OR u.uid = '${provider}|${uid}' OR u.email = $email RETURN u`,
            {
              provider: provider,
              uid: uid,
              email: user.email,
            }
          );

          const uuid = uuidv4();
          const uniq = uuid.split('-')[0];

          if (result.records.length === 0) {
            const createUser = await txc.run(
              `CREATE (u:User {
              uuid: $uuid,
              uid: $uid,
              password: $password,
              username: $username,
              email: $email,
              name: $name,
              image: $image,
              provider: $provider
            })
            CREATE (p:Person {
              uuid: $uuidPerson,
              uid: $uuidPerson,
              slug: $username,
              email: $email,
              name: $name,
              image: $image
            })
            CREATE (u)-[r:IS_PERSON]->(p)
            RETURN u, r, p`,
              {
                uid: user.sub,
                provider,
                uuidPerson: uuidv4(),
                uuid: uuid,
                password: user.aud,
                username: `${user.nickname}-${uniq}`,
                email: user.email,
                name: user.name,
                image: user.picture,
              }
            );
            await txc.commit();
            return createUser.records[0].get("u").properties;
          } else {
            await txc.commit();
            return result.records[0].get("u").properties;
          }
        } catch (error) {
          console.error(error);
          await txc.rollback();
          throw new AuthenticationError("Unable to retrieve user");
        } finally {
          await session.close();
        }

        return null;
      },
      PreviewGraphGist: (root, args, context, info) => {
        return convertAsciiDocToHtml(args.asciidoc);
      },
      UpdateGraphGist: async (root, args, context, info) => {
        const session = context.driver.session();
        const txc = session.beginTransaction();

        try {
          const graphGist = await getGraphGistByUUID(txc, args.uuid);
          const {
            industries,
            use_cases,
            challenges,
            author,
            ...proprieties
          } = args.graphgist;
          const result = await txc.run(
            `
            MATCH (g:GraphGist {uuid: $uuid})<-[:IS_VERSION]-(gc:GraphGistCandidate)
            SET gc += $graphgist
            SET g += { is_candidate_updated: TRUE, has_errors: FALSE }
            RETURN gc
          `,
            {
              uuid: args.uuid,
              graphgist: {
                ...proprieties,
                raw_html: convertAsciiDocToHtml(proprieties.asciidoc),
                has_errors: false,
              },
            }
          );
          const candidate = result.records[0].get("gc").properties;

          await txc.run(
            `
            MATCH (gc:GraphGistCandidate {uuid: $uuid})<-[r:WROTE]-()
            DELETE r
          `,
            { uuid: candidate.uuid }
          );
          await txc.run(
            `
            MATCH (gc:GraphGistCandidate {uuid: $uuid}), (a:Person {uuid: $authorUuid})
            CREATE (gc)<-[r:WROTE]-(a)
            RETURN r
          `,
            { uuid: candidate.uuid, authorUuid: author }
          );

          await txc.run(
            `
            MATCH (gc:GraphGistCandidate {uuid: $uuid})-[r:FOR_CHALLENGE|:FOR_USE_CASE|:FOR_INDUSTRY]->()
            DELETE r
          `,
            { uuid: candidate.uuid }
          );
          var categoryUuid;

          for (categoryUuid of industries) {
            const res = await txc.run(
              `
              MATCH (gc:GraphGistCandidate {uuid: $uuid}), (c:Industry {uuid: $categoryUuid})
              CREATE (gc)-[r:FOR_INDUSTRY]->(c)
              RETURN r
            `,
              { uuid: candidate.uuid, categoryUuid }
            );
          }

          for (categoryUuid of use_cases) {
            await txc.run(
              `
              MATCH (gc:GraphGistCandidate {uuid: $uuid}), (c:UseCase {uuid: $categoryUuid})
              CREATE (gc)-[r:FOR_USE_CASE]->(c)
              RETURN r
            `,
              { uuid: candidate.uuid, categoryUuid }
            );
          }

          for (categoryUuid of challenges) {
            await txc.run(
              `
              MATCH (gc:GraphGistCandidate {uuid: $uuid}), (c:Challenge {uuid: $categoryUuid})
              CREATE (gc)-[r:FOR_CHALLENGE]->(c)
              RETURN r
            `,
              { uuid: candidate.uuid, categoryUuid }
            );
          }

          await txc.commit();
          return candidate;
        } catch (error) {
          console.error(error);
          await txc.rollback();
          throw error;
        } finally {
          await session.close();
        }

        return null;
      },
    },
    Query: {
      me: async (obj, args, context, info) => {
        try {
          const user = await context.user;
          if (user) {
            return neo4jgraphql(obj, { uuid: user.uuid }, context, info);
          }
        } catch (error) {
          console.error(error);
        }
        return null;
      },
      getGraphGistCandidate: async (obj, args, context, info) => {
        const session = context.driver.session();
        const txc = session.beginTransaction();
        const { uuid: graphGistUUID } = args;

        try {
          const graphGist = await getGraphGistByUUID(txc, graphGistUUID);
          if (!graphGist) {
            throw new Error("GraphGist not found");
          }

          const result = await txc.run(
            `
            MATCH (g:GraphGist {uuid: $uuid})<-[:IS_VERSION]-(c:GraphGistCandidate)
            RETURN c
          `,
            { uuid: graphGistUUID }
          );

          let candidateUUID;
          if (result.records.length > 0) {
            await txc.commit();
            candidateUUID = result.records[0].get("c").properties.uuid;
          } else {
            candidateUUID = uuidv4();
            const createResult = await txc.run(
              `
              MATCH (g:GraphGist {uuid: $uuid})
              MERGE (c:GraphGistCandidate)-[r:IS_VERSION]->(g)
              SET c = g
              SET c.uuid = $candidateUUID
              WITH c, g

              MATCH (g)<-[r:WROTE]-(p)
              WITH collect(p) as endNodes, c, g
              FOREACH(pp in endNodes | CREATE (c)<-[:WROTE]-(pp))
              WITH c, g

              MATCH (g)-[r:FOR_CHALLENGE]->(p)
              WITH collect(p) as endNodes, c, g
              FOREACH(pp in endNodes | CREATE (c)-[:FOR_CHALLENGE]->(pp))
              WITH c, g

              MATCH (g)-[r:FOR_INDUSTRY]->(p)
              WITH collect(p) as endNodes, c, g
              FOREACH(pp in endNodes | CREATE (c)-[:FOR_INDUSTRY]->(pp))
              WITH c, g

              MATCH (g)-[r:FOR_USE_CASE]->(p)
              WITH collect(p) as endNodes, c, g
              FOREACH(pp in endNodes | CREATE (c)-[:FOR_USE_CASE]->(pp))
              WITH c, g

              MATCH (g)-[r:HAS_IMAGE]->(p)
              WITH collect(p) as endNodes, c, g
              FOREACH(pp in endNodes | CREATE (c)-[:HAS_IMAGE]->(pp))
              WITH c, g

              RETURN c
            `,
              {
                uuid: graphGistUUID,
                candidateUUID,
              }
            );
            await txc.commit();
          }

          return neo4jgraphql(obj, { uuid: candidateUUID }, context, info);
        } catch (error) {
          console.error(error);
          await txc.rollback();
        } finally {
          await session.close();
        }

        return null;
      },
    },
    Image: {
      source_url: (obj, args, context, info) => {
        const {
          uuid,
          source_file_name,
          source_updated_at,
        } = obj.source_url.properties;
        const size = "medium";
        const partitions = uuid
          .match(/.{9}/g)[0]
          .match(/.{1,3}/g)
          .join("/");
        return `https://${S3_BUCKET_NAME}.s3.amazonaws.com/graph_starter/images/sources/${partitions}/${size}/${source_file_name}?${source_updated_at}`;
      },
    },
    GraphGist: {
      my_perms: async (obj, args, context, info) => {
        try {
          const user = await context.user;

          if (user.admin) {
            return ["edit", "delete"];
          }

          if (user.uuid === obj.author.uuid) {
            return ["edit"];
          }
        } catch (error) {
          console.error(error);
        }

        return [];
      },
    },
    GraphGistCandidate: {
      my_perms: async (obj, args, context, info) => {
        try {
          const user = await context.user;

          if (user.admin) {
            return ["edit", "delete"];
          }

          if (user.uuid === obj.author.uuid) {
            return ["edit"];
          }
        } catch (error) {
          console.error(error);
        }

        return [];
      },
    },
  },
  config: {
    mutation: false,
  },
});

/*
 * Create a new ApolloServer instance, serving the GraphQL schema
 * created using makeAugmentedSchema above and injecting the Neo4j driver
 * instance into the context object so it is available in the
 * generated resolvers to connect to the database.
 */
const server = new ApolloServer({
  context: ({ req }) => {
    const user = getUser(driver, req);
    return {
      driver,
      user,
    };
  },
  schema: schema,
  introspection: true,
  playground: true,
});

// Specify port and path for GraphQL endpoint
const port = process.env.PORT || process.env.GRAPHQL_LISTEN_PORT || 4001;
const path = "/graphql";

/*
 * Optionally, apply Express middleware for authentication, etc
 * This also also allows us to specify a path for the GraphQL endpoint
 */
server.applyMiddleware({ app, path });

app.listen({ port, path }, () => {
  console.log(`GraphQL server ready at http://localhost:${port}${path}`);
});
